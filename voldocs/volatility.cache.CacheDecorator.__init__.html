<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>volatility.cache.CacheDecorator.__init__ : API documentation</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <link href="apidocs.css" type="text/css" rel="stylesheet" />
    
    
  </head>
  <body>
    <h1 class="method">v.c.C.__init__(self, path) : method documentation</h1>
    <p>
      <span id="part">Part of <a href="volatility.html">volatility</a>.<a href="volatility.cache.html">cache</a>.<a href="volatility.cache.CacheDecorator.html">CacheDecorator</a></span>
      
      
    </p>
    <div>
      
    </div>
    <pre>Wraps a function in a cache decorator.

The results of the function will be cached and memoised. Further
calls to the function will retrieve the result from the
cache. Cached objects are stored with the specified path as a
key.

Args:
   path: Key for storage into the cache. If this is callable,
   it will be called with the function's args and is expected
   to return a string which will be used as a path.

Returns:
   A decorator.

Example: Suppose the calculate function is decorated:

@CacheDecorator(lambda self: "tests/pslist/pid{0}/".format(self._config.PID))
def calculate(self):
   ....

Note the use of the callback to finely tune the cache key depending on external variables.</pre>

    
    
    <div id="splitTables">
      
      
      
    </div>
    
    
    

    
    <address>
      <a href="index.html">API Documentation</a> for Volatility 2.2, generated by <a href="http://codespeak.net/~mwh/pydoctor/">pydoctor</a> at 2013-06-24 15:16:10.
    </address>
  </body>
</html>