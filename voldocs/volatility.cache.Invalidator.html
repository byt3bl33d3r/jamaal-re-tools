<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>volatility.cache.Invalidator : API documentation</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <link href="apidocs.css" type="text/css" rel="stylesheet" />
    
    
  </head>
  <body>
    <h1 class="class">v.c.Invalidator(<span title="object">object</span>) : class documentation</h1>
    <p>
      <span id="part">Part of <a href="volatility.html">volatility</a>.<a href="volatility.cache.html">cache</a></span>
      
      <a href="classIndex.html#volatility.cache.Invalidator">View In Hierarchy</a>
    </p>
    <div>
      
    </div>
    <div>The Invalidator encapsulates program state to control
invalidation of the cache.</p>
<p>1) This object registers callbacks using the add_condition()
method.</p>
<p>2) Prior to serialising the cache object the callbacks are called
returning a signature dict.</p>
<p>3) When unpickling the cached object, we call the invalidator to
produce a signature dict again, and compare this to the pickled
version.</p>
<p>The purpose of the callbacks is to represent a signature of the
current state of execution. If the signature changes, the cache is
invalidated.<table class="fieldTable"></table></div>

    
    
    <div id="splitTables">
      <table class="children sortable" id="id1390">
  
  
<tr class="method">
    
    
    <td>Method</td>
    <td><a href="volatility.cache.Invalidator.html#__init__">__init__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="volatility.cache.Invalidator.html#add_condition">add_condition</a></td>
    <td><span>Callback will be stored under key and should return a string.</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="volatility.cache.Invalidator.html#__setstate__">__setstate__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="volatility.cache.Invalidator.html#__getstate__">__getstate__</a></td>
    <td><span class="undocumented">No summary</span></td>
  </tr>
  
</table>
      
      
    </div>
    
    
    

    <div class="function">
  <a name="volatility.cache.Invalidator.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    def
    __init__(self):
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="function">
  <a name="volatility.cache.Invalidator.add_condition">
    
  </a>
  <a name="add_condition">
    
  </a>
  <div class="functionHeader">
    
    def
    add_condition(self, key, callback):
    
  </div>
  <div class="functionBody">
    
    <div>Callback will be stored under key and should return a string.<table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="volatility.cache.Invalidator.__setstate__">
    
  </a>
  <a name="__setstate__">
    
  </a>
  <div class="functionHeader">
    
    def
    __setstate__(self, state):
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="function">
  <a name="volatility.cache.Invalidator.__getstate__">
    
  </a>
  <a name="__getstate__">
    
  </a>
  <div class="functionHeader">
    
    def
    __getstate__(self):
    
  </div>
  <div class="functionBody">
    
    <div>When pickling ourselves we call our callbacks to provide a
dict of strings (our state signature). This dict should
reflect all of our running state at the moment. This will then
be compared to the state signature when unpickling and if its
different we invalidate the cache.<table class="fieldTable"></table></div>
  </div>
</div>
    <address>
      <a href="index.html">API Documentation</a> for volatility, generated by <a href="http://codespeak.net/~mwh/pydoctor/">pydoctor</a> at 2013-06-22 21:05:12.
    </address>
  </body>
</html>